---
phase: 02-generation-engine
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-05"]
files_modified:
  - src/app/api/admin/generate/route.ts
  - src/app/api/admin/status/[jobId]/route.ts
  - src/components/admin/generation-trigger.tsx
  - src/components/admin/generation-status.tsx
  - src/app/admin/(dashboard)/generate/page.tsx
  - src/app/admin/(dashboard)/generate/generation-page.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can trigger report generation with topic input"
    - "Generation creates a job record in database"
    - "Status endpoint returns current job progress"
    - "UI shows real-time progress during 5-15 minute generation"
    - "Completed reports are saved to reports table"
    - "Failed generations show error message"
  artifacts:
    - path: "src/app/api/admin/generate/route.ts"
      provides: "POST endpoint to start generation job"
      exports: ["POST"]
    - path: "src/app/api/admin/status/[jobId]/route.ts"
      provides: "GET endpoint for job status"
      exports: ["GET"]
    - path: "src/components/admin/generation-trigger.tsx"
      provides: "Topic input form with submit"
      exports: ["GenerationTrigger"]
    - path: "src/components/admin/generation-status.tsx"
      provides: "Polling status display"
      exports: ["GenerationStatus"]
    - path: "src/app/admin/(dashboard)/generate/page.tsx"
      provides: "Generation page combining trigger and status"
      min_lines: 30
  key_links:
    - from: "src/components/admin/generation-trigger.tsx"
      to: "/api/admin/generate"
      via: "form submission"
      pattern: "POST.*generate"
    - from: "src/components/admin/generation-status.tsx"
      to: "/api/admin/status/[jobId]"
      via: "SWR polling"
      pattern: "useSWR.*status"
    - from: "src/app/api/admin/generate/route.ts"
      to: "src/lib/gemini/client.ts"
      via: "generateReport call"
      pattern: "generateReport"
---

<objective>
Create the report generation trigger with async job tracking and real-time progress feedback using SWR polling.

Purpose: This is the core feature - admin triggers generation, sees progress, and gets a published report. The 5-15 minute generation time requires async architecture.

Output: Generation API endpoint, status polling, trigger UI with progress display.
</objective>

<execution_context>
@/Users/matanbenhaim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matanbenhaim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-generation-engine/02-CONTEXT.md
@.planning/phases/02-generation-engine/02-RESEARCH.md

@src/lib/gemini/client.ts
@src/lib/gemini/schemas.ts
@src/lib/trends/client.ts
@src/components/admin/topic-selector.tsx
@src/types/database.ts
@src/lib/admin/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generation and status API endpoints</name>
  <files>
    src/app/api/admin/generate/route.ts
    src/app/api/admin/status/[jobId]/route.ts
  </files>
  <action>
1. Create `src/app/api/admin/generate/route.ts`:
   ```typescript
   import { createClient } from '@/lib/supabase/server';
   import { generateReport } from '@/lib/gemini/client';
   import { NextResponse } from 'next/server';

   export async function POST(request: Request) {
     const supabase = await createClient();
     const { data: { user } } = await supabase.auth.getUser();

     // Admin check
     if (!user || user.email !== process.env.ADMIN_EMAIL) {
       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
     }

     const { topic, categoryId } = await request.json();

     if (!topic || topic.trim().length < 3) {
       return NextResponse.json({ error: 'Topic is required (min 3 chars)' }, { status: 400 });
     }

     // Get category name for prompt
     const { data: category } = await supabase
       .from('categories')
       .select('name')
       .eq('id', categoryId)
       .single();

     // Create job record
     const { data: job, error: jobError } = await supabase
       .from('generation_jobs')
       .insert({
         topic: topic.trim(),
         category_id: categoryId,
         status: 'pending',
       })
       .select()
       .single();

     if (jobError) {
       return NextResponse.json({ error: 'Failed to create job' }, { status: 500 });
     }

     // Start generation in background (fire and forget)
     // The actual generation runs asynchronously
     runGeneration(job.id, topic.trim(), category?.name || 'General', supabase);

     return NextResponse.json({ jobId: job.id });
   }

   async function runGeneration(
     jobId: string,
     topic: string,
     categoryName: string,
     supabase: any
   ) {
     try {
       // Update to generating
       await supabase
         .from('generation_jobs')
         .update({ status: 'generating', progress: 'Starting AI generation...' })
         .eq('id', jobId);

       // Generate report with progress updates
       const report = await generateReport(topic, categoryName, async (message) => {
         await supabase
           .from('generation_jobs')
           .update({ progress: message })
           .eq('id', jobId);
       });

       // Update to validating
       await supabase
         .from('generation_jobs')
         .update({ status: 'validating', progress: 'Saving report...' })
         .eq('id', jobId);

       // Get category ID for the report
       const { data: cat } = await supabase
         .from('categories')
         .select('id')
         .eq('name', categoryName)
         .single();

       // Create slug from title
       const slug = report.title
         .toLowerCase()
         .replace(/[^a-z0-9]+/g, '-')
         .replace(/^-|-$/g, '');

       // Save report
       const { data: savedReport, error: saveError } = await supabase
         .from('reports')
         .insert({
           slug: `${slug}-${Date.now()}`,
           title: report.title,
           subtitle: report.subtitle,
           summary: report.summary,
           content: report.content,
           sources: report.sources,
           seo_title: report.seo_title,
           seo_description: report.seo_description,
           seo_keywords: report.seo_keywords,
           category_id: cat?.id,
           status: 'published',
           published_at: new Date().toISOString(),
           word_count: report.content.split(/\s+/).length,
           reading_time: Math.ceil(report.content.split(/\s+/).length / 200),
         })
         .select()
         .single();

       if (saveError) throw saveError;

       // Record in topic history
       await supabase.from('topic_history').insert({
         topic,
         category_id: cat?.id,
         report_id: savedReport.id,
       });

       // Mark complete
       await supabase
         .from('generation_jobs')
         .update({
           status: 'completed',
           report_id: savedReport.id,
           progress: 'Report published successfully!',
           completed_at: new Date().toISOString(),
         })
         .eq('id', jobId);

     } catch (error: any) {
       await supabase
         .from('generation_jobs')
         .update({
           status: 'failed',
           error: error.message || 'Unknown error',
           progress: 'Generation failed',
           completed_at: new Date().toISOString(),
         })
         .eq('id', jobId);
     }
   }
   ```

2. Create `src/app/api/admin/status/[jobId]/route.ts`:
   ```typescript
   import { createClient } from '@/lib/supabase/server';
   import { NextResponse } from 'next/server';

   export async function GET(
     request: Request,
     { params }: { params: Promise<{ jobId: string }> }
   ) {
     const supabase = await createClient();
     const { data: { user } } = await supabase.auth.getUser();

     if (!user || user.email !== process.env.ADMIN_EMAIL) {
       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
     }

     const { jobId } = await params;

     const { data: job, error } = await supabase
       .from('generation_jobs')
       .select('*')
       .eq('id', jobId)
       .single();

     if (error || !job) {
       return NextResponse.json({ error: 'Job not found' }, { status: 404 });
     }

     return NextResponse.json(job);
   }
   ```

NOTE: The generation runs in-process using the "fire and forget" pattern. This works within Vercel's timeout limits if using Pro plan with extended duration. The function returns the job ID immediately while generation continues.

IMPORTANT: In Next.js 15, params are async and need to be awaited.
  </action>
  <verify>
    `npx tsc --noEmit` - TypeScript compiles
  </verify>
  <done>
    - POST /api/admin/generate starts job and returns jobId
    - GET /api/admin/status/[jobId] returns job status
    - Generation runs asynchronously
    - Report saved on completion
  </done>
</task>

<task type="auto">
  <name>Task 2: Create generation trigger and status components</name>
  <files>
    src/components/admin/generation-trigger.tsx
    src/components/admin/generation-status.tsx
  </files>
  <action>
1. Create `src/components/admin/generation-trigger.tsx`:
   ```typescript
   'use client';

   import { useState } from 'react';
   import { TopicSelector } from './topic-selector';

   interface Props {
     categories: { id: string; name: string }[];
     todayCategoryId: string;
     onJobStarted: (jobId: string) => void;
   }

   export function GenerationTrigger({ categories, todayCategoryId, onJobStarted }: Props) {
     const [topic, setTopic] = useState('');
     const [categoryId, setCategoryId] = useState(todayCategoryId);
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState('');

     // Get selected category name for TopicSelector
     const selectedCategory = categories.find((c) => c.id === categoryId);

     async function handleSubmit(e: React.FormEvent) {
       e.preventDefault();
       setLoading(true);
       setError('');

       try {
         const res = await fetch('/api/admin/generate', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ topic, categoryId }),
         });

         const data = await res.json();

         if (!res.ok) {
           throw new Error(data.error || 'Failed to start generation');
         }

         onJobStarted(data.jobId);
       } catch (err: any) {
         setError(err.message);
       } finally {
         setLoading(false);
       }
     }

     return (
       <form onSubmit={handleSubmit} className="space-y-6">
         <div>
           <label className="block text-sm font-medium mb-2">Category</label>
           <select
             value={categoryId}
             onChange={(e) => setCategoryId(e.target.value)}
             className="w-full px-4 py-2 bg-background border border-border rounded-md"
             disabled={loading}
           >
             {categories.map((cat) => (
               <option key={cat.id} value={cat.id}>
                 {cat.name} {cat.id === todayCategoryId ? "(Today's)" : ''}
               </option>
             ))}
           </select>
         </div>

         <TopicSelector
           categoryName={selectedCategory?.name || ''}
           value={topic}
           onChange={setTopic}
           disabled={loading}
         />

         {error && (
           <p className="text-red-500 text-sm">{error}</p>
         )}

         <button
           type="submit"
           disabled={loading || topic.length < 3}
           className="w-full px-4 py-3 bg-primary text-primary-foreground rounded-md font-medium hover:bg-primary/90 disabled:opacity-50 transition-colors"
         >
           {loading ? 'Starting Generation...' : 'Generate Test Report'}
         </button>

         <p className="text-xs text-muted-foreground text-center">
           Generation takes 5-15 minutes. You'll see progress updates below.
         </p>
       </form>
     );
   }
   ```

2. Create `src/components/admin/generation-status.tsx`:
   ```typescript
   'use client';

   import useSWR from 'swr';
   import { useRouter } from 'next/navigation';

   const fetcher = (url: string) => fetch(url).then((r) => r.json());

   interface Props {
     jobId: string;
     onComplete?: () => void;
   }

   export function GenerationStatus({ jobId, onComplete }: Props) {
     const router = useRouter();

     const { data: job, error } = useSWR(
       `/api/admin/status/${jobId}`,
       fetcher,
       {
         refreshInterval: 3000, // Poll every 3 seconds
         isPaused: () => job?.status === 'completed' || job?.status === 'failed',
       }
     );

     if (error) {
       return (
         <div className="p-4 bg-red-500/10 border border-red-500 rounded-md">
           <p className="text-red-500">Failed to load job status</p>
         </div>
       );
     }

     if (!job) {
       return (
         <div className="p-4 bg-muted rounded-md animate-pulse">
           <p>Loading job status...</p>
         </div>
       );
     }

     const statusColors = {
       pending: 'bg-gray-500/10 border-gray-500 text-gray-400',
       generating: 'bg-amber-500/10 border-amber-500 text-amber-400',
       validating: 'bg-blue-500/10 border-blue-500 text-blue-400',
       completed: 'bg-green-500/10 border-green-500 text-green-400',
       failed: 'bg-red-500/10 border-red-500 text-red-400',
     };

     return (
       <div className={`p-4 border rounded-md ${statusColors[job.status as keyof typeof statusColors]}`}>
         <div className="flex items-center justify-between mb-2">
           <span className="font-medium capitalize">{job.status}</span>
           {job.status === 'generating' && (
             <span className="animate-pulse text-xl">‚óè</span>
           )}
         </div>

         <p className="text-sm">{job.progress || 'Waiting...'}</p>

         {job.status === 'failed' && job.error && (
           <p className="mt-2 text-sm text-red-400">Error: {job.error}</p>
         )}

         {job.status === 'completed' && job.report_id && (
           <div className="mt-4 flex gap-3">
             <button
               onClick={() => {
                 router.push(`/admin/reports`);
               }}
               className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
             >
               View Reports
             </button>
             <button
               onClick={onComplete}
               className="px-4 py-2 border border-border rounded-md hover:bg-muted"
             >
               Generate Another
             </button>
           </div>
         )}
       </div>
     );
   }
   ```

Use SWR for polling - it handles cleanup automatically when component unmounts.
  </action>
  <verify>
    `npx tsc --noEmit` - TypeScript compiles
  </verify>
  <done>
    - GenerationTrigger form uses TopicSelector for topic input
    - GenerationStatus polls every 3s and shows progress
    - Status colors indicate current state
    - Completed state shows link to reports
  </done>
</task>

<task type="auto">
  <name>Task 3: Create generation page</name>
  <files>
    src/app/admin/(dashboard)/generate/page.tsx
    src/app/admin/(dashboard)/generate/generation-page.tsx
  </files>
  <action>
Create `src/app/admin/(dashboard)/generate/page.tsx`:

```typescript
import { createClient } from '@/lib/supabase/server';
import { GenerationPage } from './generation-page';

export default async function GeneratePage() {
  const supabase = await createClient();

  // Get all categories
  const { data: categories } = await supabase
    .from('categories')
    .select('id, name, day_of_week')
    .order('day_of_week');

  // Get today's category
  const dayOfWeek = new Date().getDay();
  const todayCategory = categories?.find((c) => c.day_of_week === dayOfWeek);

  return (
    <div className="max-w-2xl mx-auto">
      <h1 className="text-2xl font-playfair font-bold mb-2">Generate Test Report</h1>
      <p className="text-muted-foreground mb-8">
        This is for QA testing only. Select a trending topic or enter your own to generate an investigative report.
      </p>

      <GenerationPage
        categories={categories || []}
        todayCategoryId={todayCategory?.id || ''}
      />
    </div>
  );
}
```

Create `src/app/admin/(dashboard)/generate/generation-page.tsx`:

```typescript
'use client';

import { useState } from 'react';
import { GenerationTrigger } from '@/components/admin/generation-trigger';
import { GenerationStatus } from '@/components/admin/generation-status';

interface Props {
  categories: { id: string; name: string }[];
  todayCategoryId: string;
}

export function GenerationPage({ categories, todayCategoryId }: Props) {
  const [activeJobId, setActiveJobId] = useState<string | null>(null);

  return (
    <div className="space-y-8">
      {!activeJobId ? (
        <GenerationTrigger
          categories={categories}
          todayCategoryId={todayCategoryId}
          onJobStarted={setActiveJobId}
        />
      ) : (
        <div className="space-y-4">
          <h2 className="text-lg font-medium">Generation Progress</h2>
          <GenerationStatus
            jobId={activeJobId}
            onComplete={() => setActiveJobId(null)}
          />
        </div>
      )}
    </div>
  );
}
```

The page flow:
1. Show trigger form with TopicSelector initially
2. Category select determines which trends are shown
3. When job started, show status component
4. Poll for updates every 3 seconds
5. On complete, allow starting new generation or viewing reports
  </action>
  <verify>
    1. Run dev server, login, visit /admin/generate
    2. Category selector and topic selector display
    3. Trending topics shown for selected category
    4. Submit starts generation and shows status
  </verify>
  <done>
    - Generation page accessible at /admin/generate
    - TopicSelector shows trending topics for selected category
    - Form shows today's category as default
    - Status updates display during generation
    - Can start new generation after completion
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - no TypeScript errors
2. `npm run build` - builds successfully
3. Visit /admin/generate - form displays with TopicSelector
4. Change category - trends refresh
5. Select trend or enter topic - topic field updates
6. Submit - job created and polling starts
7. Status updates every 3 seconds
8. (Full test requires GEMINI_API_KEY configured)
</verification>

<success_criteria>
- Admin can trigger report generation from dashboard
- Topic selector shows trending topics from Google Trends
- Real-time progress shown during 5-15 min generation
- Completed reports saved to database
- Failed generations show clear error messages
- Multiple generations can be triggered sequentially
</success_criteria>

<output>
After completion, create `.planning/phases/02-generation-engine/02-04-SUMMARY.md`
</output>
