---
phase: 03-automation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/cron/utils.ts
  - src/lib/generation/runner.ts
  - src/app/api/cron/generate/route.ts
  - src/app/api/admin/generate/route.ts
  - src/components/admin/generation-status.tsx
autonomous: true

must_haves:
  truths:
    - "Cron endpoint returns 401 for requests without valid CRON_SECRET"
    - "Cron endpoint returns 200 OK if report already exists today (idempotent)"
    - "Duplicate report detection works via date-based query"
    - "Stuck jobs (>30 min generating) are auto-marked as failed"
    - "Cron endpoint triggers generation using existing fire-and-forget pattern"
    - "Failed jobs have a retry button in the dashboard"
  artifacts:
    - path: "src/lib/cron/utils.ts"
      provides: "Idempotency and logging functions"
      exports: ["hasReportForToday", "hasInProgressJob", "cleanupStuckJobs", "logCronRun"]
    - path: "src/lib/generation/runner.ts"
      provides: "Shared generation runner for admin and cron endpoints"
      exports: ["runGeneration"]
    - path: "src/app/api/cron/generate/route.ts"
      provides: "Secure cron endpoint with idempotency"
      exports: ["GET"]
    - path: "src/components/admin/generation-status.tsx"
      provides: "Retry button for failed generations"
      contains: "retry"
  key_links:
    - from: "src/app/api/cron/generate/route.ts"
      to: "src/lib/cron/utils.ts"
      via: "import idempotency checks"
      pattern: "from '@/lib/cron/utils'"
    - from: "src/app/api/cron/generate/route.ts"
      to: "src/lib/generation/runner.ts"
      via: "import runGeneration"
      pattern: "from '@/lib/generation/runner'"
    - from: "src/app/api/admin/generate/route.ts"
      to: "src/lib/generation/runner.ts"
      via: "import shared runner"
      pattern: "from '@/lib/generation/runner'"
---

<objective>
Implement the cron endpoint with idempotency checks, failure recovery utilities, and dashboard retry functionality.

Purpose: Complete the automation loop - Vercel cron triggers secured endpoint, endpoint validates auth, checks for duplicates, cleans up stuck jobs, and starts generation using the existing fire-and-forget pattern.
Output: Working /api/cron/generate endpoint, cron utility functions, shared generation runner, and retry button for failed jobs.
</objective>

<execution_context>
@/Users/matanbenhaim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matanbenhaim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-automation/03-CONTEXT.md
@.planning/phases/03-automation/03-RESEARCH.md

# Prior phase context
@.planning/phases/02-generation-engine/02-02-SUMMARY.md
@.planning/phases/02-generation-engine/02-04-SUMMARY.md
@.planning/phases/02-generation-engine/02-05-SUMMARY.md

# Files to integrate with
@src/app/api/admin/generate/route.ts
@src/lib/gemini/client.ts
@src/lib/trends/client.ts
@src/components/admin/generation-status.tsx
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cron utility functions</name>
  <files>src/lib/cron/utils.ts</files>
  <action>
Create src/lib/cron/utils.ts with idempotency checks and logging functions:

```typescript
import { SupabaseClient } from '@supabase/supabase-js';
import { CronRun } from '@/types/database';

/**
 * Check if a report has already been published today (UTC)
 */
export async function hasReportForToday(
  supabase: SupabaseClient
): Promise<boolean> {
  const today = new Date();
  today.setUTCHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);

  const { count } = await supabase
    .from('reports')
    .select('*', { count: 'exact', head: true })
    .gte('published_at', today.toISOString())
    .lt('published_at', tomorrow.toISOString());

  return (count ?? 0) > 0;
}

/**
 * Check if any generation job is currently in progress
 */
export async function hasInProgressJob(
  supabase: SupabaseClient
): Promise<boolean> {
  const { count } = await supabase
    .from('generation_jobs')
    .select('*', { count: 'exact', head: true })
    .eq('status', 'generating');

  return (count ?? 0) > 0;
}

/**
 * Mark stuck jobs as failed (generating for >30 minutes)
 */
export async function cleanupStuckJobs(
  supabase: SupabaseClient
): Promise<void> {
  const thirtyMinutesAgo = new Date();
  thirtyMinutesAgo.setMinutes(thirtyMinutesAgo.getMinutes() - 30);

  await supabase
    .from('generation_jobs')
    .update({
      status: 'failed',
      error: 'Job timed out (stuck for >30 minutes)',
      completed_at: new Date().toISOString(),
    })
    .eq('status', 'generating')
    .lt('started_at', thirtyMinutesAgo.toISOString());
}

/**
 * Log a cron run to the database
 */
export async function logCronRun(
  supabase: SupabaseClient,
  data: Partial<CronRun>
): Promise<void> {
  await supabase.from('cron_runs').insert(data);
}
```

Implementation notes:
- Use UTC dates for all time comparisons
- hasReportForToday checks published_at between 00:00 and 23:59 UTC today
- cleanupStuckJobs uses 30-minute threshold (generation typically takes 5-15 min)
- logCronRun accepts partial data since some fields are populated after completion
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
All functions exported: `grep "export async function" src/lib/cron/utils.ts`
Contains 4 functions: hasReportForToday, hasInProgressJob, cleanupStuckJobs, logCronRun
  </verify>
  <done>
Cron utilities module exports all idempotency and logging functions with proper UTC handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract runGeneration to shared module</name>
  <files>src/lib/generation/runner.ts, src/app/api/admin/generate/route.ts</files>
  <action>
Extract runGeneration from the admin generate endpoint to a shared module for reuse by cron endpoint.

1. Create src/lib/generation/runner.ts by extracting the generation logic:

```typescript
import { SupabaseClient } from '@supabase/supabase-js';
import { generateReport } from '@/lib/gemini/client';

/**
 * Run the full generation workflow: AI generation -> validation -> save to database
 * Uses fire-and-forget pattern - caller receives immediate response while this runs async
 */
export async function runGeneration(
  jobId: string,
  topic: string,
  categoryName: string,
  supabase: SupabaseClient
): Promise<void> {
  try {
    // Update status to generating
    await supabase
      .from('generation_jobs')
      .update({
        status: 'generating',
        progress: 'Starting AI generation...',
        started_at: new Date().toISOString(),
      })
      .eq('id', jobId);

    // Generate report with progress updates
    const report = await generateReport(topic, categoryName, async (message) => {
      await supabase
        .from('generation_jobs')
        .update({ progress: message })
        .eq('id', jobId);
    });

    // Update status to validating
    await supabase
      .from('generation_jobs')
      .update({ status: 'validating', progress: 'Saving report...' })
      .eq('id', jobId);

    // Get category ID
    const { data: category } = await supabase
      .from('categories')
      .select('id')
      .eq('name', categoryName)
      .single();

    // Create slug from title
    const slug = report.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');

    // Save report to database
    const { data: savedReport, error: saveError } = await supabase
      .from('reports')
      .insert({
        slug: `${slug}-${Date.now()}`,
        title: report.title,
        subtitle: report.subtitle,
        summary: report.summary,
        content: report.content,
        sources: report.sources,
        seo_title: report.seo_title,
        seo_description: report.seo_description,
        seo_keywords: report.seo_keywords,
        category_id: category?.id,
        status: 'published',
        published_at: new Date().toISOString(),
        word_count: report.content.split(/\s+/).length,
        reading_time: Math.ceil(report.content.split(/\s+/).length / 200),
      })
      .select()
      .single();

    if (saveError) throw saveError;

    // Record in topic history
    await supabase.from('topic_history').insert({
      topic,
      category_id: category?.id,
      report_id: savedReport.id,
    });

    // Mark job as completed
    await supabase
      .from('generation_jobs')
      .update({
        status: 'completed',
        report_id: savedReport.id,
        progress: 'Report published successfully!',
        completed_at: new Date().toISOString(),
      })
      .eq('id', jobId);
  } catch (error: unknown) {
    // Mark job as failed
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    await supabase
      .from('generation_jobs')
      .update({
        status: 'failed',
        error: errorMessage,
        progress: 'Generation failed',
        completed_at: new Date().toISOString(),
      })
      .eq('id', jobId);
  }
}
```

2. Update src/app/api/admin/generate/route.ts to use the shared module:
- Remove the inline runGeneration function definition
- Add import: `import { runGeneration } from '@/lib/generation/runner';`
- Keep the POST handler unchanged - it should already be calling runGeneration

The admin endpoint should now import and use the shared runner instead of defining it locally.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Shared module exists: `ls src/lib/generation/runner.ts`
Admin route imports from shared: `grep "from '@/lib/generation/runner'" src/app/api/admin/generate/route.ts`
Runner exports function: `grep "export async function runGeneration" src/lib/generation/runner.ts`
  </verify>
  <done>
runGeneration is now a shared module usable by both admin and cron endpoints. Admin endpoint refactored to use it.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create cron endpoint with idempotency and security</name>
  <files>src/app/api/cron/generate/route.ts</files>
  <action>
Create src/app/api/cron/generate/route.ts as the secured endpoint Vercel cron will invoke:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getDailyTrends } from '@/lib/trends/client';
import { runGeneration } from '@/lib/generation/runner';
import {
  hasReportForToday,
  hasInProgressJob,
  cleanupStuckJobs,
  logCronRun,
} from '@/lib/cron/utils';

export async function GET(request: NextRequest) {
  const startedAt = new Date().toISOString();
  const supabase = await createClient();

  // 1. Validate CRON_SECRET
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('Unauthorized', { status: 401 });
  }

  // 2. Weekend check (extra safety - schedule already excludes weekends)
  const today = new Date();
  const dayOfWeek = today.getUTCDay();
  if (dayOfWeek === 0 || dayOfWeek === 6) {
    await logCronRun(supabase, {
      started_at: startedAt,
      completed_at: new Date().toISOString(),
      status: 'skipped',
      skip_reason: 'Weekend - no generation scheduled',
    });
    return NextResponse.json({ success: true, message: 'Weekend - skipped' });
  }

  // 3. Idempotency check - report already exists for today
  if (await hasReportForToday(supabase)) {
    await logCronRun(supabase, {
      started_at: startedAt,
      completed_at: new Date().toISOString(),
      status: 'skipped',
      skip_reason: 'Report already generated today',
    });
    return NextResponse.json({ success: true, message: 'Already generated today' });
  }

  // 4. Cleanup stuck jobs and check for in-progress
  await cleanupStuckJobs(supabase);
  if (await hasInProgressJob(supabase)) {
    await logCronRun(supabase, {
      started_at: startedAt,
      completed_at: new Date().toISOString(),
      status: 'skipped',
      skip_reason: 'Generation already in progress',
    });
    return NextResponse.json({ success: true, message: 'Generation in progress' });
  }

  // 5. Get today's category (day_of_week: 1=Mon, 5=Fri)
  const { data: category, error: catError } = await supabase
    .from('categories')
    .select('id, name')
    .eq('day_of_week', dayOfWeek)
    .single();

  if (catError || !category) {
    await logCronRun(supabase, {
      started_at: startedAt,
      completed_at: new Date().toISOString(),
      status: 'failed',
      error: `No category for day ${dayOfWeek}: ${catError?.message || 'not found'}`,
    });
    return NextResponse.json({ error: 'Category not found' }, { status: 500 });
  }

  // 6. Get trending topic
  const trends = await getDailyTrends();
  const topic = trends[0]?.title || `${category.name} Analysis`;

  // 7. Create generation job
  const { data: job, error: jobError } = await supabase
    .from('generation_jobs')
    .insert({
      topic,
      category_id: category.id,
      status: 'pending',
    })
    .select()
    .single();

  if (jobError || !job) {
    await logCronRun(supabase, {
      started_at: startedAt,
      completed_at: new Date().toISOString(),
      status: 'failed',
      topic,
      category_name: category.name,
      error: `Failed to create job: ${jobError?.message || 'unknown'}`,
    });
    return NextResponse.json({ error: 'Failed to create job' }, { status: 500 });
  }

  // 8. Log cron start
  await logCronRun(supabase, {
    started_at: startedAt,
    completed_at: new Date().toISOString(),
    status: 'success',
    topic,
    category_name: category.name,
  });

  // 9. Start generation (fire-and-forget)
  runGeneration(job.id, topic, category.name, supabase);

  return NextResponse.json({
    success: true,
    jobId: job.id,
    topic,
    category: category.name,
  });
}
```

Key implementation details:
- Returns 401 without valid CRON_SECRET in Authorization header
- Returns 200 with skip message if report exists (idempotent)
- Cleans up stuck jobs before checking in-progress status
- Uses fire-and-forget pattern (doesn't await runGeneration) to return quickly
- Logs every execution to cron_runs table for dashboard visibility
  </action>
  <verify>
File exists: `ls src/app/api/cron/generate/route.ts`
Exports GET: `grep "export async function GET" src/app/api/cron/generate/route.ts`
Validates CRON_SECRET: `grep "CRON_SECRET" src/app/api/cron/generate/route.ts`
Uses cron utils: `grep "hasReportForToday\|cleanupStuckJobs" src/app/api/cron/generate/route.ts`
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
Cron endpoint validates CRON_SECRET, performs idempotency checks, and triggers generation using shared runner.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add retry button to generation status component</name>
  <files>src/components/admin/generation-status.tsx</files>
  <action>
Update src/components/admin/generation-status.tsx to add a retry button for failed jobs.

Add retry functionality:

1. Add props to component interface:
```typescript
interface GenerationStatusProps {
  jobId: string;
  onRetry?: (newJobId: string) => void;
}
```

2. Add retry handler function inside component:
```typescript
const handleRetry = async () => {
  if (!job) return;

  try {
    const response = await fetch('/api/admin/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        topic: job.topic,
        categoryId: job.category_id,
      }),
    });

    const data = await response.json();

    if (response.ok && data.jobId) {
      // Call parent callback to update to new job
      onRetry?.(data.jobId);
    }
  } catch (error) {
    console.error('Retry failed:', error);
  }
};
```

3. Add retry button in the UI (only show when status is 'failed'):
```tsx
{job?.status === 'failed' && (
  <Button
    onClick={handleRetry}
    variant="outline"
    size="sm"
    className="mt-4"
  >
    Retry Generation
  </Button>
)}
```

Place the button after the error message display, before any other action buttons.

Note: The retry uses the existing POST /api/admin/generate endpoint which doesn't have idempotency checks (those are only in the cron endpoint), so retries will always create a new job.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Retry button exists: `grep -i "retry" src/components/admin/generation-status.tsx`
onRetry prop added: `grep "onRetry" src/components/admin/generation-status.tsx`
  </verify>
  <done>
Failed generation jobs show retry button that creates a new generation job with the same topic and category.
  </done>
</task>

</tasks>

<verification>
1. All files created: `ls src/lib/cron/utils.ts src/lib/generation/runner.ts src/app/api/cron/generate/route.ts`
2. TypeScript compiles: `npx tsc --noEmit`
3. Cron endpoint security: `grep "CRON_SECRET" src/app/api/cron/generate/route.ts`
4. Idempotency checks: `grep "hasReportForToday\|hasInProgressJob" src/app/api/cron/generate/route.ts`
5. Shared runner used: `grep "from '@/lib/generation/runner'" src/app/api/admin/generate/route.ts src/app/api/cron/generate/route.ts`
6. Build succeeds: `npm run build`
</verification>

<success_criteria>
- Cron utilities (hasReportForToday, hasInProgressJob, cleanupStuckJobs, logCronRun) implemented with UTC handling
- runGeneration extracted to shared module used by both admin and cron endpoints
- /api/cron/generate endpoint validates CRON_SECRET (returns 401 without it)
- Endpoint performs idempotency checks and returns 200 OK with skip message if report exists today
- Endpoint creates generation job and starts async generation using fire-and-forget pattern
- Retry button appears on failed jobs in generation status component
- TypeScript compiles and build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-automation/03-02-SUMMARY.md`
</output>
